执行上下文：EC
  当前代码被解析和执行时所在的环境。
  js中分为（1）全局执行上下文（2）函数执行上下文
  执行上下文创建过程的过程为：
    1）创建变量对象VO：初始化函数的arguments，提升函数声明和变量声明
    2）创建作用域链
    3）确定this的值
    AO=>变量和形参声明，形参实参统一，函数声明
执行栈/调用栈：ECStack
  用于描述函数间的调用和等待关系，具有后进先出的结构，存储在代码执行期间创建的所有执行上下文。
    1）首次运行JS代码的时候，会创建一个全局执行的上下文，压入执行栈，
       每当函数调用时，引擎会为该函数创建一个新的函数执行上下文，压入栈顶。
    2）当栈顶的函数运行完成，函数上下文会从执行栈中弹出

作用域（词法作用域）：Scope chain
  负责维护当前代码关于所有声明的标识符（变量）的访问权限。
  js采用词法作用域，作用域由代码书写时的位置决定（with和eval可以修改词法作用域）
  作用域分为：
    1）全局作用域
    2）函数作用域
    3）块级作用域
作用域链：
  从当前作用域开始一层一层向上寻找变量，直到找到变量，如果到全局作用域都没有找到就放弃。
  这种一层一层的关系，就是作用域链。作用域存在遮蔽效益，即同名变量内部作用域声明会屏蔽外部的变量。

闭包：
  当函数可以记住并访问定义时的作用域时就产生了闭包，即使函数是在当前词法作用域之外执行。
  函数嵌套函数，内部函数引用外部函数变量，且存在全局变量是内部函数的引用，当外部函数一执行就产生闭包。
    1）能够阻止词法作用域的回收
    2）私有化变量
    3）模块化


当某个函数第一次被调用时，就会创建一个执行环境(execution context)以及相应的作用域链，
并把作用域链赋值给一个特殊的内部属性([scope])。
然后使用this，arguments(arguments在全局环境中不存在)和其他命名参数的值
来初始化函数的活动对象(activation object)。
当前执行环境的AO变量对象始终在作用域链的第0位。

AO = VO + function parameters + arguments