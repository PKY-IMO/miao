1.JSONP（AJAX）
  网页通过添加一个<script>元素，向服务器请求JSON数据，这种做法不受同源政策限制；服务器收到请求后，将数据放在一个指定名字的回调函数里传回来。
  注意点：1.只支持get方法 2.调用失败没有状态码提示 3.存在安全隐患

2.WebSocket (AJAX)
  WebSocket是一种通信协议，使用ws://（非加密）和wss://（加密）作为协议前缀。该协议不实行同源政策，只要服务器支持，就可以通过它进行跨源通信。

3.CORS (AJAX)
  浏览器端发送：Origin字段;  
  跨域默认不携带cookie;   xhr.withCredentials = true  Access-Control-Allow-Credentials=true
  如果要发送Cookie，服务器Access-Control-Allow-Origin就不能设为星号，必须指定明确的、与请求网页一致的域名。同时，Cookie依然遵循同源政策，只有用服务器域名设置的Cookie才会上传，其他域名的Cookie并不会上传。
  
  简单请求+非简单请求
  非简单请求需要前端预检，浏览器主动发出OPTIONS请求 
  Access-Control-Request-Method Access-Control-Request-Headers
  一旦服务器通过了"预检"请求，以后每次浏览器正常的CORS请求，就都跟简单请求一样，会有一个Origin头信息字段。服务器的回应，也都会有一个Access-Control-Allow-Origin头信息字段。

4.postMessage（跨文档通信API）
  localStorage解决跨域问题：postMessage
  postMessage(data,origin) + iframe  / url


cookie：
1.特定域名最多生成20个
2.最大存储4k
3.安全性问题 csrf

会话cookie 和 持久cookie
  会话：max-age expires 退出浏览器自动删除
  持久：存储在硬盘

工作机制：
  服务器设置set-cookie：id=“123”；domain:"xxx.com";HTTPOnly;samesite;
  httponly:后台设置通过js脚本将无法读取到cookie信息，（避免xss攻击）
  samesite:后台设置是否携带第三方cookie，三个值：strict，lax，none （避免csrf攻击）
      strict：完全禁止第三方 Cookie，跨站点时都不会发送 Cookie， URL与请求目标一致，才会带上 Cookie。
      lax：get请求可以
      none：网站可以选择显式关闭SameSite属性，将其设为None。不过，前提是必须同时设置Secure属性
  secure:只能通过https传输

跨域（1）两个网页一级域名相同，只是二级域名不同
        浏览器允许通过设置document.domain共享 Cookie。（只适用于 Cookie 和 iframe 窗口）
    （2）服务器设置domain，指定Cookie的所属域名为一级域名：
        Set-Cookie: key=value; domain=.example.com;

xss
  cookie：HTTPOnly

content-security-policy 网页安全策略CSP
script-src和object-src是必设的，除非设置了default-src
connect-src 页面中js能够通过（xhr、websocket）与那些服务器通信
sript-src 页面能加载哪里的js   (字符串可以作为代码执行)
frame-src
font-src
form-action

setTimeOut( t(), 100)
function t() {
  alert(1)
  console.log(2)
  return 'alert(3)'
}