//å®ç°æ•°ç»„map()æ–¹æ³•
Array.prototype.myMap = function (callback, thisArg) {
  let length = this.length
  let res = []
  if (!Array.isArray(this)) throw new TypeError('this is not an array')
  if (typeof callback !== 'function') throw new TypeError(callback + 'is not a function')
  if (length === 0) {
    return res
  }
  for (let i = 0; i < length; i++) {
    res[i] = callback.call(thisArg, this[i], i, this)
  }
  return res
}
//é˜²æŠ–
function debounce(f, delay) {
  let timer = null
  return function () {
    if(timer) clearTimeout(timer)
    timer = setTimeout(f, delay)
  }
}

//äºŒåˆ†æŸ¥æ‰¾
function sortedIndex(arr, value) {
  // arræ˜¯å·²æ’åºçš„æ•°ç»„
  if (arr.length == 0) return 0
  if (arr[arr.length-1] < value) return arr.length
  // åœ¨[left, right]ä¸­æ‰¾åˆ°å¤§äºç­‰äºvalueçš„ç¬¬ä¸€ä¸ªå…ƒç´ çš„ä½ç½®
  let l = 0, r = arr.length - 1
  while(l < r) {
    let mid = (l + r) >> 1
    if (arr[mid] < value) l = mid + 1
    else r = mid
  }
  return l
}
åœ†ç¯/å†’æ³¡

æ‹¼æ¥å­—ç¬¦ä¸²å’Œæ’åºçš„é¢˜



//å°†ä¸¤ä¸ªæœ‰åºæ•°ç»„åˆå¹¶æˆä¸€ä¸ªæœ‰åºæ•°ç»„
var merge = function(nums1, m, nums2, n) {
    let k = m + n - 1, i = m - 1, j = n - 1
    while (i >= 0 || j >= 0) {
        if (i < 0) nums1[k--] = nums2[j--]
        else if (j < 0) nums1[k--] = nums1[i--]
        else if (nums1[i] > nums2[j]) nums1[k--] = nums1[i--]
        else nums1[k--] = nums2[j--]
    }
};
//å¿«æ’
function quickSort(arr, start=0, end=arr.length-1) {
  if(start >= end) return 
  let pivotIdx = Math.floor(Math.random()*(end - start + 1)) + start
  let pivot = arr[pivotIdx]
  let l = start, r = end
  while(l <= r) {
    while(l <= r && arr[l] < pivot) l++
    while(l <= r && arr[r] > pivot) r--
    if (l <= r) {
      [arr[l],arr[r]] = [arr[r],arr[l]];
      l++
      r--
    }
  }
  quickSort(arr, start, r)
  quickSort(arr, l, end)
  return arr
}
//æ±‚æ ‘çš„é«˜åº¦ï¼ˆé€’å½’å’Œå±‚æ¬¡ï¼‰
var maxDepth = function(root) {
    if (root == null) return 0
    let left = maxDepth(root.left)
    let right = maxDepth(root.right)
    return Math.max(left, right) + 1
};
var maxDepth2 = function (root) {
  if (root == null) return []
  let res = []
  let queue = []
  let cur = root
  queue.push(cur)
  while(queue.length) {
    let size = queue.length
    let tmp = []
    for (let i = 0; i < size; i++) {
      let node = queue.shift()
      tmp.push(node)
      if (node.left) queue.push(node.left)
      if (node.right) queue.push(node.right)
    }
    res.push(tmp)
  }
  return res.length
}
//ä¸¤æ•°ä¹‹å’Œ
var twoSum = function(nums, target) {
    let map = new Map()
    for (let i = 0; i < nums.length; i++) {
        if (map.has(target - nums[i])) {
            return [i,map.get(target - nums[i])]
        }else {
            map.set(nums[i], i)
        }
    }
};
//ä¸‰å”ä¹‹å’Œ
var threeSum = function(nums) {
    nums.sort((a,b)=>a-b)
    let res = []
    for (let i = 0; i < nums.length; i++) {
        if(nums[i] > 0) break
        if(i>0 && nums[i-1] === nums[i]) continue
        let l = i+1, r = nums.length-1
        while(l < r) {
            let sum = nums[i] + nums[l] + nums[r]
            if (sum === 0) {
                res.push([nums[i],nums[l],nums[r]])
                while(l < r && nums[l] === nums[++l]);
                while(l < r && nums[r] === nums[--r]);
            }else if (sum < 0) {
                l++
            }else {
                r--
            }
        }
    }
    return res
 
};
//findKtop
var findKthLargest = function(nums, k) {
  function quickSort(arr, k, start) {
    if (arr.length <= 1) return arr[0]
    let pivotIdx = arr.length >> 1
    let pivot = arr.splice(pivotIdx, 1)[0]//è¦æŠŠè¿™ä¸ªæ•°å»æ‰
    let left = []
    let right = []
    for (let i = 0; i < arr.length; i++) {
      if (arr[i] < pivot) {
        left.push(arr[i])
      }else {
        right.push(arr[i])
      }
    }
    if ((left.length + start) == k) {
      return pivot
    }else if ((left.length + start) > k) {
      return quickSort(left, k, start)
    }else {
      return quickSort(right, k, left.length + start + 1)
    }
  }
  return quickSort(nums, nums.length - k, 0)
}
æ•°ç»„æ‰å¹³åŒ–
function flat3(arr) {
  return arr.reduce((prev,item)=>prev.concat(Array.isArray(item) ? flat3(item) : item),[])
}
è¯·ç”¨ç¨‹åºåˆ¤æ–­ä¸€ä¸ªéç©ºå­—ç¬¦ä¸²æ˜¯å¦æ˜¯ç”±æ‰€å«çš„ä¸€ä¸ªå­ä¸²é‡å¤å¤šæ¬¡ç»„æˆï¼Œå­—ç¬¦ä¸²åªåŒ…å«å°å†™å­—æ¯ä¸”é•¿åº¦ä¸è¶…è¿‡5000ã€‚
ä¸¾ä¾‹ï¼šabdeabdeabdeï¼Œè¿”å›trueï¼Œabdeabdeabdï¼Œè¿”å›false

ç®—æ³•é¢˜ï¼šæ ‘å½¢ç»“æ„è½¬æ•°ç»„ç»“æ„
//map æ”¯æŒå¤šä¸ªæ ¹èŠ‚ç‚¹ âˆš
function list2tree(list) {
  let res = []
  let map = {}
  list.forEach(node=> {
    node.children = []
    map[node.id] = node
  })
  list.forEach(node=> {
    if(map[node.pid]) {
      map[node.pid].children.push(node)
    }else {
      res.push(node)
    }
  })
  return res
}
ä¸­ç¼€è¡¨è¾¾å¼è½¬åç¼€è¡¨è¾¾å¼
æ‰‹å†™es5.ES6ç±»çš„åˆ›é€ æ–¹æ³•
url äºŒçº§åŸŸå
//([{}])æ‹¬å·åŒ¹é…
var isValid = function(s) {
    let n = s.length
    let stack = []
    for(let i = 0; i < n; i++) {
        switch (s[i]) {
            case '(': 
                stack.push(')')
                break
            case '[': 
                stack.push(']')
                break
            case '{': 
                stack.push('}')
                break   
            default:
                if (stack.pop() != s[i])
                return false         
        }
    }
    return stack.length == 0
};

//
format('aa{0}bbcc{1}','bb','cc') //aabbbbcccc
function format(originStr, ...args) {
  return originStr.replace(/\{(\d)\}/g, (match, i)=>args[i])
}

//å¯¹è±¡å±•å¼€
function falttenObj(obj) {
  const res = {}
  const flatObj = (obj, preKey='') => {
    if (typeof obj != 'object') {
      res[preKey] == obj
      return
    }
    let keys = Object.keys(obj)
    for (let key of keys) {
      let value = obj[key]
      let newKey = key
      if (preKey) {
        newKey = preKey + '.' + key
      }
      if (typeof value === 'object') {
        flatObj(value, newKey)
      }
      if (typeof value !== 'object') {
        res[newKey] = value
      }
    }
  }
  flatObj(obj, '')
  return res
}



function maxRequest(url = ``, times = 3) {
  // 1. é—­åŒ…ï¼Œä¿å­˜ç§æœ‰å±æ€§
  function autoRetry (url, times) {
    console.log('times = ', times);
    times--;
    // 2. fetch æœ¬èº«è¿”å›å€¼å°±æ˜¯ Promiseï¼Œä¸éœ€è¦å†æ¬¡ä½¿ç”¨ Promise åŒ…è£¹
    return fetch(url).then(value => {
        if(value.status === 200) {
          console.log(`âœ… OK`, value);
          // 3. æ‰‹åŠ¨è¿”å› Promise çš„ valueï¼Œ æ²¡æœ‰è¿”å›å€¼ é»˜è®¤è¿”å› undefined
          return value;
        } else {
          throw new Error(`âŒ  http code error: ${value.status }`);
        }
      }).catch((err) => {
        console.log(`âŒ  Error`, err);
        if (times < 1) {
          // 4. æ–¹ä¾¿åç»­çš„ thenable å¤„ç† error
          throw new Error('ğŸ’©  over max request times!');
        } else {
          // 5. è¿”å›é€’å½’æ–¹æ³• 
          return autoRetry(url, times);
        }
      });
  }
  // 6. è¿”å›ä¸€ä¸ª Promise çš„ç»“æœ ï¼ˆæˆåŠŸ Promise æˆ–å¤±è´¥ Promiseï¼‰
  return autoRetry(url, times);
}