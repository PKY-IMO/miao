1. 事件代理-事件委托
  “事件代理”即是把原本需要绑定在子元素的响应事件（click、keydown......）委托给父元素，
  让父元素担当事件监听的职务。事件代理的原理是DOM元素的事件冒泡。
  （1）减少内存-需要绑定的事件（2）动态绑定-为新的节点绑定事件
2. 不使用setState，直接this.state
    直接写不更新将不会重新渲染组件
    react实现更新的原理并不是vue那样的双向绑定，
    而是在你设置state之后，随之产生一个更新任务，
    任务的出现触发更新调度。
    setState的作用正是去创建任务，标记哪个fiber节点产生了更新，并触发任务调度。
3. context
    React跨层级传递数据的工具
    createcontext  provider value包裹
    class组件：consumer包裹 + contextType + this.context
    函数组件： useContext
4. 防抖节流
  防抖-输入框联想：触发事件后在 n 秒内函数只能执行一次，如果在 n 秒内又触发了事件，则会重新计算函数执行时间。
  节流：指连续触发事件但是在 n 秒中只执行一次函数。节流会稀释函数的执行频率。
5. 输入url发生了什么
  （1）浏览器的地址栏输入URL并按下回车。
  （2）浏览器查找当前URL是否存在缓存，并比较缓存是否过期。
  （3）DNS解析URL对应的IP。
  （4）根据IP建立TCP连接（三次握手）。
  （5）HTTP发起请求。
  （6）服务器处理请求，浏览器接收HTTP响应。
  （7）渲染页面，构建DOM树。
  （8）关闭TCP连接（四次挥手）。
6. http缓存
7. 操作系统、进程、虚拟内存
  虚拟存储技术的实质:通过页表建立虚拟空间和物理空间之间的映射+MMU
  页面置换算法：最佳+先进先出+最近最长未使用
8. 进程之间的通信 7种
      匿名管道（半双工），命名管道fifo（半双工）、消息队列（消息的链表）、共享内存、套接字socket、信号量Semaphore-计数器、信号sing
   线程之间的通信：线程间的通信目的主要是用于线程同步，所以线程没有像进程通信中的用于数据交换的通信机制。
      锁机制（互斥、读写）、信号量、信号
9.  node.js
10. ts泛型
  ts基本类型：string、number、boolean、any、null、undefined、never、enum、void、数组、元组
  可以把泛型理解为代表类型的参数，使接口，函数或类更加通用 T,K,V,E
  泛型是指在定义函数、接口或类的时候，不预先指定具体的类型，使用时再去指定类型的一种特性。
    泛型约束：泛型可以通过 extends 一个接口来实现泛型约束，写法如：<泛型变量 extends 接口>
  例： interface Test<T = any> {
        userId: T;
      }
      type TestA = Test<string>;
      type TestB = Test<number>;
      const a: TestA = {
          userId: '111',
      };
      const b: TestB = {
          userId: 2222,
      };
11. 前端优化
  加载时的优化：http请求、缓存、静态资源cdn、图片优化、字体、服务端渲染、gzip压缩、懒加载
  运行时的优化：减少重排重绘、事件委托、虚拟化长列表
12. 前端安全
  XSS跨站脚本攻击：反射（URL）、存储（数据库）、dom
    是一种代码注入攻击。攻击者通过在目标网站上注入恶意脚本，使之在用户的浏览器上运行。
    利用这些恶意脚本，攻击者可获取用户的敏感信息如 Cookie、SessionID 等，进而危害数据安全。
  通用解决方案：React、vue框架自带虚拟dom （hydrate、href=’xss‘）
    csp白名单
    csp白名单：响应头或者meat标签设置content-Security-policy：script-src 'slef';
  dom解决方案：字符转义、禁止js开头的a链接
  存储反射：纯前端渲染，过滤用户输入数据、禁止js访问cookie：HttpOnly

  CSRF跨站请求伪造：
  一般在第三方网站发生，冒用受害者cookie信息骗取服务器信任
  解决方案：
    （csrf已死）cookie samesite：strict lax可get none必须secure
    验证码、token、referer域名校验

  中间人攻击：
  https降级为http
13. js v8 js运行时是单线程还是多线程
  单线程
14. 线程进程区别
  (1) 进程是资源分配的最小单位，线程是程序执行的最小单位（资源调度的最小单位）
  (2) 进程有自己的独立地址空间，而线程是共享进程中的数据的，使用相同的地址空间
  (3) 线程之间的通信更方便，同一进程下的线程共享全局变量、静态变量等数据，
       而进程之间的通信需要以通信的方式（IPC)进行。
  (4) 多线程程序只要有一个线程死掉，整个进程也死掉了；
        一个进程死掉并不会对另外一个进程造成影响，因为进程有自己独立的地址空间。
15. 锁和死锁
  锁：封锁就是一个事务可向系统提出请求，对被操作的数据加锁（Lock）。
      其他事务必须等到此事务解锁（Unlock）之后才能访问该数据。
      从而，在多个用户并发访问数据库时，确保不互相干扰。
  死锁：就是当两个或两个以上的线程因竞争相同资源而处于无限期的等待，
      这样就导致了多个线程的阻塞，出现程序无法正常运行和终止的情况。
  可锁定的单位是：行、页、表、盘区和数据库。
  死锁产生的四个条件：互斥、请求保持、不剥夺、循环等待
  避免死锁：银行家算法

16. 银行家算法
   操作系统分配资源给进程的方法：避免死锁
      当一个进程对资源的最大需求量不超过系统的资源数时，可以接纳该进程
      进程可以分期请求资源，但请求的总数不能超过最大需求量，
      系统现有资源不能满足进程时，请求可以推迟分配，总能使得进程在有限的时间内获得资源
17. 哲学家就餐
    五个哲学家其中有一个哲学家首先要先获取右边的筷子，
    再试图去获取左边的筷子，其他哲 学家是先获取左边筷子，再获取右边筷子。
    方案一：规定奇数号科学家先拿左边的筷子，然后拿右边的筷子。
            偶数号科学家先拿右边的筷子，然后那左边的筷子。
            导致0，1科学家竞争1号筷子，2，3科学家竞争3号筷子。
            四号科学家无人竞争。最后总有一个科学家能获得两只筷子。
    方案二：至多允许四个哲学家同时去拿左边的筷子，
            最终保证至少有一个科学家能进餐，并且用完之后释放筷子，
            从而使更多的哲学家能够拿到筷子。

16. obj.x与obj[x]有何不同，什么情况下是相同的？
  obj.x 读取“x”属性
  读取的x求值结果作为属性名
  例： const a = {}
      const b = {c:2}
      a[b] = 3
  //a的结果 {'[object Object]': 3}

17. [] == ![]  true   0->false 
    {} == !{}  false  `[object Object]`-> true
    [] == false true